<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OpenPDF Prototype</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f5f5f7;
      --panel: #ffffff;
      --border: #d0d0d7;
      --accent: #3f51b5;
      --text: #1f1f24;
      --secondary: #4b4b55;
      --note: #fff8c6;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.75rem 1rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.75rem;
      z-index: 5;
    }

    header h1 {
      font-size: 1.1rem;
      margin: 0 1.5rem 0 0;
      font-weight: 600;
    }

    button, label.tool-button {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      border-radius: 6px;
      padding: 0.45rem 0.75rem;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      transition: background 0.15s, border-color 0.15s, transform 0.15s;
      user-select: none;
    }

    button:hover, label.tool-button:hover {
      border-color: var(--accent);
    }

    button.active, label.tool-button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 250px 1fr 280px;
      gap: 1rem;
      padding: 1rem;
      overflow: hidden;
    }

    body.comments-collapsed main {
      grid-template-columns: 250px 1fr;
    }

    body.comments-collapsed #comment-panel {
      display: none;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
    }

    #thumbnails {
      padding: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      overflow-y: auto;
    }

    .thumbnail {
      border: 2px solid transparent;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      cursor: grab;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 200px;
      transition: border-color 0.15s, box-shadow 0.15s;
    }

    .thumbnail.active {
      border-color: var(--accent);
    }

    .thumbnail.dragging {
      opacity: 0.7;
      cursor: grabbing;
      box-shadow: 0 8px 20px rgba(17, 24, 39, 0.18);
    }

    .thumbnail canvas {
      width: 100%;
      height: auto;
      display: block;
    }

    #viewer-panel {
      position: relative;
      overflow: auto;
    }

    #page-container {
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
    }

    .page {
      position: relative;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 4px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.1);
      overflow: visible;
    }

    .page.hidden {
      display: none;
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .overlay.active {
      pointer-events: auto;
    }

    .drawing-layer {
      position: absolute;
      inset: 0;
    }

    .annotation-layer {
      position: absolute;
      inset: 0;
    }

    .text-box {
      position: absolute;
      min-width: 80px;
      min-height: 40px;
      padding: 0.25rem 0.35rem;
      border: 1px solid transparent;
      border-radius: 4px;
      background: rgba(255,255,255,0.85);
      color: var(--text);
      font-size: 16px;
      line-height: 1.4;
      cursor: move;
    }

    .text-box:focus {
      outline: 2px solid var(--accent);
      border-color: var(--accent);
      cursor: text;
    }

    .note-card {
      position: absolute;
      padding: 0.4rem 0.5rem;
      background: var(--note);
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      color: #3f3210;
      width: 160px;
      cursor: move;
    }

    .image-box {
      position: absolute;
      border: 2px solid transparent;
      border-radius: 4px;
      overflow: hidden;
      cursor: move;
    }

    .image-box.active {
      border-color: var(--accent);
    }

    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent);
      bottom: -6px;
      right: -6px;
      cursor: nwse-resize;
    }

    #toolbar {
      display: flex;
      gap: 0.5rem;
      padding: 0.65rem 0.75rem;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.85);
      position: sticky;
      top: 0;
      z-index: 2;
    }

    #toolbar .section {
      display: inline-flex;
      gap: 0.4rem;
      align-items: center;
      padding-right: 0.8rem;
      border-right: 1px solid var(--border);
    }

    #toolbar .section:last-child {
      border-right: none;
    }

    #color-picker,
    #stroke-width,
    #font-size {
      padding: 0.3rem;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
    }

    #comment-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #toggle-comments-btn {
      margin-left: auto;
    }

    #comment-panel h2 {
      margin: 0;
      padding: 0.9rem;
      border-bottom: 1px solid var(--border);
      font-size: 1rem;
    }

    #comment-list {
      list-style: none;
      margin: 0;
      padding: 0;
      overflow-y: auto;
      flex: 1;
    }

    #comment-list li {
      border-bottom: 1px solid var(--border);
      padding: 0.75rem 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    #comment-list li.highlight {
      background: rgba(63,81,181,0.12);
    }

    #comment-list li strong {
      font-size: 0.85rem;
      color: var(--secondary);
    }

    #comment-list li p {
      margin: 0;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    #comment-list li:hover {
      background: rgba(63,81,181,0.08);
      cursor: pointer;
    }

    .comment-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      display: grid;
      place-items: center;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transform: translate(-50%, -50%);
    }

    .comment-marker.active {
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 0 0 0 6px rgba(63,81,181,0.15);
    }

    #empty-state {
      margin: auto;
      text-align: center;
      max-width: 360px;
      color: var(--secondary);
    }

    #empty-state h2 {
      font-weight: 600;
    }

    .thumbnail-drop-indicator {
      position: absolute;
      width: 100%;
      height: 4px;
      background: var(--accent);
      left: 0;
      top: -2px;
      display: none;
    }

    .hidden-input {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .toast {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      background: #111827;
      color: #fff;
      padding: 0.75rem 1.2rem;
      border-radius: 999px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      z-index: 10;
    }

    .toast.show {
      opacity: 1;
    }

    @media (max-width: 1200px) {
      main {
        grid-template-columns: 200px 1fr;
        grid-template-areas:
          "thumbnails viewer"
          "comments viewer";
        grid-auto-rows: minmax(0,1fr);
      }

      #thumbnails-panel {
        grid-area: thumbnails;
      }

      #comment-panel {
        grid-area: comments;
      }

      body.comments-collapsed main {
        grid-template-columns: 200px 1fr;
        grid-template-areas:
          "thumbnails viewer"
          "thumbnails viewer";
      }
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
      }

      #viewer-panel {
        order: -1;
      }

      body.comments-collapsed main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto;
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <header>
    <h1>OpenPDF Prototype</h1>
    <input id="file-input" class="hidden-input" type="file" accept="application/pdf" />
    <button id="open-btn">Open PDF</button>
    <button id="download-btn" disabled>Export PDF</button>
    <button id="add-page-btn" disabled>Add Blank Page</button>
    <button id="duplicate-page-btn" disabled>Duplicate Page</button>
    <button id="toggle-comments-btn" aria-expanded="true" aria-controls="comment-panel">Hide Comments</button>
  </header>
  <main>
    <section class="panel" id="thumbnails-panel">
      <div id="thumbnails"></div>
    </section>
    <section class="panel" id="viewer-panel">
      <div id="toolbar">
        <div class="section" id="tool-buttons">
          <button data-tool="select" class="active">Select</button>
          <button data-tool="draw">Pen</button>
          <button data-tool="text">Text</button>
          <button data-tool="note">Note</button>
          <button data-tool="comment">Comment</button>
          <button data-tool="image">Image</button>
          <button data-tool="redact">Whiteout</button>
        </div>
        <div class="section">
          <label>Color <input type="color" id="color-picker" value="#ff3b30"></label>
          <label>Stroke <input type="number" id="stroke-width" value="3" min="1" max="12" /></label>
          <label>Font <input type="number" id="font-size" value="18" min="8" max="48" /></label>
        </div>
      </div>
      <div id="page-container">
        <div id="empty-state">
          <h2>Drop a PDF to get started</h2>
          <p>Use the toolbar to annotate, comment, reorder pages, and export your updated document. Drag and drop a PDF anywhere or tap "Open PDF".</p>
        </div>
      </div>
    </section>
    <aside class="panel" id="comment-panel">
      <h2>Comments</h2>
      <ul id="comment-list"></ul>
    </aside>
  </main>
  <input type="file" id="image-input" class="hidden-input" accept="image/*" />
  <div class="toast" id="toast"></div>
  <script>
    const PDF_JS_WORKER_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js';
    let pdfjsLib = window['pdfjs-dist/build/pdf'] || window.pdfjsLib || null;
    if (pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = PDF_JS_WORKER_SRC;
    }

    const state = {
      pages: [],
      tool: 'select',
      color: '#ff3b30',
      strokeWidth: 3,
      fontSize: 18,
      activePageIndex: 0,
      dragInfo: null,
      draggedPageIndex: null,
      pendingImagePosition: null,
      commentCounter: 1,
      commentsCollapsed: false,
    };

    const elements = {
      fileInput: document.getElementById('file-input'),
      openBtn: document.getElementById('open-btn'),
      downloadBtn: document.getElementById('download-btn'),
      addPageBtn: document.getElementById('add-page-btn'),
      duplicatePageBtn: document.getElementById('duplicate-page-btn'),
      toggleCommentsBtn: document.getElementById('toggle-comments-btn'),
      thumbnails: document.getElementById('thumbnails'),
      pageContainer: document.getElementById('page-container'),
      toolbar: document.getElementById('toolbar'),
      toolButtons: document.querySelectorAll('#tool-buttons button'),
      colorPicker: document.getElementById('color-picker'),
      strokeWidth: document.getElementById('stroke-width'),
      fontSize: document.getElementById('font-size'),
      commentList: document.getElementById('comment-list'),
      imageInput: document.getElementById('image-input'),
      toast: document.getElementById('toast'),
      emptyState: document.getElementById('empty-state'),
    };

    const THUMBNAIL_MAX_WIDTH = 260;
    const THUMBNAIL_MAX_HEIGHT = 420;

    function getCanvasPixelRatio() {
      const ratio = window.devicePixelRatio || 1;
      return Math.min(3, Math.max(1, ratio));
    }

    const createId = (() => {
      let counter = 0;
      return (prefix) => `${prefix}-${++counter}`;
    })();

    setCommentsCollapsed(state.commentsCollapsed);

    function getDraggingPageIndex(event) {
      if (typeof state.draggedPageIndex === 'number') {
        return state.draggedPageIndex;
      }
      const rawData = event.dataTransfer?.getData('text/plain') || '';
      const parsedIndex = parseInt(rawData, 10);
      return Number.isNaN(parsedIndex) ? null : parsedIndex;
    }

    elements.thumbnails.addEventListener('dragover', (event) => {
      event.preventDefault();
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = 'move';
      }
    });

    elements.thumbnails.addEventListener('drop', (event) => {
      if (event.target !== elements.thumbnails) {
        return;
      }
      event.preventDefault();
      const draggingIndex = getDraggingPageIndex(event);
      if (draggingIndex == null) return;
      movePage(draggingIndex, state.pages.length);
      state.draggedPageIndex = null;
    });

    function showToast(message) {
      elements.toast.textContent = message;
      elements.toast.classList.add('show');
      setTimeout(() => elements.toast.classList.remove('show'), 2200);
    }

    function setCommentsCollapsed(collapsed) {
      state.commentsCollapsed = collapsed;
      document.body.classList.toggle('comments-collapsed', collapsed);
      if (elements.toggleCommentsBtn) {
        elements.toggleCommentsBtn.textContent = collapsed ? 'Show Comments' : 'Hide Comments';
        elements.toggleCommentsBtn.setAttribute('aria-expanded', String(!collapsed));
      }
    }

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = false;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(script);
      });
    }

    let pdfjsLibLoading = null;

    async function ensurePdfJsLoaded() {
      if (pdfjsLib) {
        return pdfjsLib;
      }
      if (!pdfjsLibLoading) {
        pdfjsLibLoading = loadScript('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js')
          .then(() => {
            pdfjsLib = window['pdfjs-dist/build/pdf'] || window.pdfjsLib || null;
            if (pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
              pdfjsLib.GlobalWorkerOptions.workerSrc = PDF_JS_WORKER_SRC;
            }
            if (!pdfjsLib) {
              throw new Error('PDF.js global not available after dynamic load');
            }
            return pdfjsLib;
          })
          .catch((error) => {
            pdfjsLibLoading = null;
            throw error;
          });
      }
      return pdfjsLibLoading;
    }

    function clearDocument() {
      state.pages.forEach(page => page.container.remove());
      state.pages = [];
      elements.thumbnails.innerHTML = '';
      elements.commentList.innerHTML = '';
      state.commentCounter = 1;
      state.dragInfo = null;
      state.pendingImagePosition = null;
      elements.downloadBtn.disabled = true;
      elements.addPageBtn.disabled = true;
      elements.duplicatePageBtn.disabled = true;
      elements.pageContainer.innerHTML = '';
      elements.pageContainer.appendChild(elements.emptyState);
      elements.emptyState.style.display = '';
    }

    function setTool(tool) {
      state.tool = tool;
      elements.toolButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));
      updateOverlayInteractivity();
      showToast(`${tool.charAt(0).toUpperCase() + tool.slice(1)} tool selected`);
    }

    function updateOverlayInteractivity() {
      state.pages.forEach((page, index) => {
        if (index === state.activePageIndex) {
          page.overlay.classList.add('active');
        } else {
          page.overlay.classList.remove('active');
        }
      });
    }

    function createPageContainer(width, height, pixelRatio = getCanvasPixelRatio()) {
      const wrapper = document.createElement('div');
      wrapper.className = 'page';
      wrapper.style.width = `${width}px`;
      wrapper.style.height = `${height}px`;

      const baseCanvas = document.createElement('canvas');
      const actualWidth = Math.round(width * pixelRatio);
      const actualHeight = Math.round(height * pixelRatio);
      baseCanvas.width = actualWidth;
      baseCanvas.height = actualHeight;
      baseCanvas.style.width = `${width}px`;
      baseCanvas.style.height = `${height}px`;
      wrapper.appendChild(baseCanvas);

      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      overlay.style.width = `${width}px`;
      overlay.style.height = `${height}px`;

      const drawingLayer = document.createElement('canvas');
      drawingLayer.className = 'drawing-layer';
      drawingLayer.width = actualWidth;
      drawingLayer.height = actualHeight;
      drawingLayer.style.width = `${width}px`;
      drawingLayer.style.height = `${height}px`;
      overlay.appendChild(drawingLayer);

      const drawingContext = drawingLayer.getContext('2d');
      if (pixelRatio !== 1) {
        drawingContext.scale(pixelRatio, pixelRatio);
      }

      const annotationLayer = document.createElement('div');
      annotationLayer.className = 'annotation-layer';
      overlay.appendChild(annotationLayer);

      wrapper.appendChild(overlay);

      return { wrapper, baseCanvas, overlay, drawingLayer, drawingContext, annotationLayer, pixelRatio };
    }

    function setupPageEvents(page, index) {
      if (page.eventsBound) return;
      page.overlay.addEventListener('pointerdown', (event) => {
        if (state.pages[state.activePageIndex] !== page) return;
        handlePointerDown(event, page);
      });
      page.overlay.addEventListener('pointermove', (event) => {
        if (state.pages[state.activePageIndex] !== page) return;
        handlePointerMove(event, page);
      });
      page.overlay.addEventListener('pointerup', (event) => {
        if (state.pages[state.activePageIndex] !== page) return;
        handlePointerUp(event, page);
      });
      page.overlay.addEventListener('click', (event) => {
        if (state.pages[state.activePageIndex] !== page) return;
        handleOverlayClick(event, page, event.target);
      });
      page.eventsBound = true;
    }

    function addPage(page, insertIndex = state.pages.length) {
      state.pages.splice(insertIndex, 0, page);
      renderPageList();
      setActivePage(insertIndex);
      elements.downloadBtn.disabled = false;
      elements.addPageBtn.disabled = false;
      elements.duplicatePageBtn.disabled = false;
      elements.emptyState.style.display = 'none';
    }

    function createThumbnail(page, pageIndex) {
      const thumbnail = document.createElement('div');
      thumbnail.className = 'thumbnail';
      thumbnail.draggable = true;

      const indicator = document.createElement('div');
      indicator.className = 'thumbnail-drop-indicator';
      thumbnail.appendChild(indicator);

      const thumbCanvas = document.createElement('canvas');
      const pageWidth = page.displayWidth || page.baseCanvas.width;
      const pageHeight = page.displayHeight || page.baseCanvas.height;
      const widthScale = THUMBNAIL_MAX_WIDTH / pageWidth;
      const heightScale = THUMBNAIL_MAX_HEIGHT / pageHeight;
      const scale = Math.min(widthScale, heightScale, 1);
      const thumbWidth = Math.max(1, Math.round(pageWidth * scale));
      const thumbHeight = Math.max(1, Math.round(pageHeight * scale));
      thumbnail.style.aspectRatio = `${pageWidth} / ${pageHeight}`;
      thumbCanvas.width = thumbWidth;
      thumbCanvas.height = thumbHeight;
      thumbnail.appendChild(thumbCanvas);

      thumbnail.addEventListener('click', () => {
        setActivePage(pageIndex);
      });

      thumbnail.addEventListener('dragstart', (event) => {
        state.draggedPageIndex = Array.from(elements.thumbnails.children).indexOf(thumbnail);
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/plain', state.draggedPageIndex.toString());
        }
        thumbnail.classList.add('dragging');
      });

      thumbnail.addEventListener('dragend', () => {
        thumbnail.classList.remove('dragging');
        state.draggedPageIndex = null;
        Array.from(elements.thumbnails.querySelectorAll('.thumbnail')).forEach(el => {
          const indicator = el.querySelector('.thumbnail-drop-indicator');
          if (indicator) indicator.style.display = 'none';
        });
      });

      thumbnail.addEventListener('dragover', (event) => {
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
        const draggingIndex = getDraggingPageIndex(event);
        if (draggingIndex == null) return;
        const currentIndex = Array.from(elements.thumbnails.children).indexOf(thumbnail);
        if (draggingIndex === currentIndex) return;
        const rect = thumbnail.getBoundingClientRect();
        const indicator = thumbnail.querySelector('.thumbnail-drop-indicator');
        if (!indicator) return;
        if (event.clientY < rect.top + rect.height / 2) {
          indicator.style.top = '-2px';
          indicator.style.display = 'block';
          thumbnail.dataset.dropPosition = 'before';
        } else {
          indicator.style.top = 'calc(100% - 2px)';
          indicator.style.display = 'block';
          thumbnail.dataset.dropPosition = 'after';
        }
      });

      thumbnail.addEventListener('dragleave', () => {
        const indicator = thumbnail.querySelector('.thumbnail-drop-indicator');
        if (indicator) indicator.style.display = 'none';
        delete thumbnail.dataset.dropPosition;
      });

      thumbnail.addEventListener('drop', (event) => {
        event.preventDefault();
        event.stopPropagation();
        const draggingIndex = getDraggingPageIndex(event);
        if (draggingIndex == null) return;
        const targetIndex = Array.from(elements.thumbnails.children).indexOf(thumbnail);
        const position = thumbnail.dataset.dropPosition || 'after';
        const insertionIndex = position === 'before' ? targetIndex : targetIndex + 1;
        movePage(draggingIndex, insertionIndex);
        state.draggedPageIndex = null;
        delete thumbnail.dataset.dropPosition;
        const indicator = thumbnail.querySelector('.thumbnail-drop-indicator');
        if (indicator) indicator.style.display = 'none';
      });

      return { thumbnail, thumbCanvas };
    }

    function renderPageList() {
      elements.pageContainer.innerHTML = '';
      elements.pageContainer.appendChild(elements.emptyState);
      elements.thumbnails.innerHTML = '';
      state.pages.forEach((page, index) => {
        if (!page.container.isConnected) {
          elements.pageContainer.appendChild(page.container);
        } else {
          elements.pageContainer.appendChild(page.container);
        }
        const { thumbnail, thumbCanvas } = createThumbnail(page, index);
        elements.thumbnails.appendChild(thumbnail);
        updateThumbnailCanvas(thumbCanvas, page);
        thumbnail.classList.toggle('active', index === state.activePageIndex);
        page.container.classList.toggle('hidden', index !== state.activePageIndex);
        setupPageEvents(page, index);
      });
      updateOverlayInteractivity();
      updateCommentList();
      elements.emptyState.style.display = state.pages.length ? 'none' : '';
    }

    function updateThumbnailCanvas(canvas, page) {
      const context = canvas.getContext('2d');
      const pageWidth = page.displayWidth || page.baseCanvas.width;
      const pageHeight = page.displayHeight || page.baseCanvas.height;
      const scale = Math.min(canvas.width / pageWidth, canvas.height / pageHeight);
      const width = pageWidth * scale;
      const height = pageHeight * scale;
      context.clearRect(0, 0, canvas.width, canvas.height);
      const offsetX = (canvas.width - width) / 2;
      const offsetY = (canvas.height - height) / 2;
      context.fillStyle = '#f1f1f5';
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.drawImage(page.baseCanvas, offsetX, offsetY, width, height);
      context.drawImage(page.drawingLayer, offsetX, offsetY, width, height);
      page.annotations.texts.forEach(text => {
        context.save();
        context.fillStyle = 'rgba(255,255,255,0.85)';
        context.fillRect(offsetX + text.x * scale, offsetY + text.y * scale, text.width * scale, text.height * scale);
        context.fillStyle = text.color;
        context.font = `${Math.max(8, text.fontSize * scale)}px Inter`;
        context.textBaseline = 'top';
        const textLineHeight = Math.max(10, text.fontSize * scale * 1.2);
        wrapTextThumbnail(context, text.content, offsetX + text.x * scale + 3, offsetY + text.y * scale + 4 * scale, (text.width - 6) * scale, textLineHeight);
        context.restore();
      });
      page.annotations.notes.forEach(note => {
        context.save();
        context.fillStyle = '#fff8c6';
        context.fillRect(offsetX + note.x * scale, offsetY + note.y * scale, note.width * scale, note.height * scale);
        context.fillStyle = '#3f3210';
        context.font = `${Math.max(7, 14 * scale)}px Inter`;
        context.textBaseline = 'top';
        const noteLineHeight = Math.max(10, 16 * scale);
        wrapTextThumbnail(context, note.content, offsetX + note.x * scale + 4, offsetY + note.y * scale + 14 * scale, (note.width - 8) * scale, noteLineHeight);
        context.restore();
      });
      page.annotations.images.forEach(image => {
        const img = new Image();
        img.src = image.dataUrl;
        img.onload = () => {
          context.drawImage(img, offsetX + image.x * scale, offsetY + image.y * scale, image.width * scale, image.height * scale);
        };
      });
      page.annotations.comments.forEach(comment => {
        context.save();
        context.fillStyle = '#3f51b5';
        context.beginPath();
        context.arc(offsetX + comment.x * scale, offsetY + comment.y * scale, 8, 0, Math.PI * 2);
        context.fill();
        context.fillStyle = '#ffffff';
        context.font = '10px Inter';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(String(comment.label), offsetX + comment.x * scale, offsetY + comment.y * scale);
        context.restore();
      });
    }

    function setActivePage(index) {
      state.activePageIndex = index;
      state.pages.forEach((page, pageIndex) => {
        page.container.classList.toggle('hidden', pageIndex !== index);
      });
      Array.from(elements.thumbnails.children).forEach((thumb, thumbIndex) => {
        thumb.classList.toggle('active', thumbIndex === index);
      });
      updateOverlayInteractivity();
    }

    function movePage(fromIndex, toIndex) {
      if (fromIndex === toIndex || fromIndex < 0 || fromIndex >= state.pages.length) return;
      let targetIndex = toIndex;
      if (targetIndex < 0) targetIndex = 0;
      if (targetIndex > state.pages.length) targetIndex = state.pages.length;
      const [page] = state.pages.splice(fromIndex, 1);
      if (fromIndex < targetIndex) {
        targetIndex -= 1;
      }
      if (targetIndex < 0) targetIndex = 0;
      if (targetIndex > state.pages.length) targetIndex = state.pages.length;
      state.pages.splice(targetIndex, 0, page);
      renderPageList();
      setActivePage(targetIndex);
    }

    async function loadPdfFromArrayBuffer(arrayBuffer, fileLabel = 'PDF document') {
      let lib;
      try {
        lib = await ensurePdfJsLoaded();
      } catch (error) {
        console.error(error);
        showToast('PDF engine failed to load. Please refresh and try again.');
        return;
      }

      let pdf;
      try {
        pdf = await lib.getDocument({ data: arrayBuffer }).promise;
      } catch (error) {
        console.error(error);
        showToast('Failed to load PDF. Please try another file.');
        return;
      }

      clearDocument();

      const pixelRatio = getCanvasPixelRatio();

      for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
        const pdfPage = await pdf.getPage(pageNumber);
        const viewport = pdfPage.getViewport({ scale: 1.5 });
        const { wrapper, baseCanvas, overlay, drawingLayer, drawingContext, annotationLayer, pixelRatio: appliedRatio } = createPageContainer(viewport.width, viewport.height, pixelRatio);
        const context = baseCanvas.getContext('2d');
        const renderContext = { canvasContext: context, viewport };
        if (appliedRatio !== 1) {
          renderContext.transform = [appliedRatio, 0, 0, appliedRatio, 0, 0];
        }
        await pdfPage.render(renderContext).promise;

        const annotations = {
          drawings: [],
          texts: [],
          notes: [],
          images: [],
          redactions: [],
          comments: [],
        };

        const page = {
          container: wrapper,
          baseCanvas,
          overlay,
          drawingLayer,
          drawingContext,
          annotationLayer,
          annotations,
          pixelRatio: appliedRatio,
          displayWidth: viewport.width,
          displayHeight: viewport.height,
        };

        elements.pageContainer.appendChild(wrapper);
        state.pages.push(page);
        setupPageEvents(page, state.pages.length - 1);
      }

      renderPageList();
      setActivePage(0);
      elements.downloadBtn.disabled = state.pages.length === 0;
      elements.addPageBtn.disabled = false;
      elements.duplicatePageBtn.disabled = state.pages.length === 0;
      const pageCount = state.pages.length;
      const label = fileLabel || 'PDF document';
      showToast(`${label} loaded (${pageCount} page${pageCount === 1 ? '' : 's'})`);
    }

    function handlePointerDown(event, page) {
      const rect = page.overlay.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      if (state.tool === 'draw') {
        event.target.setPointerCapture(event.pointerId);
        state.dragInfo = {
          type: 'drawing',
          points: [{ x, y }],
        };
        page.drawingContext.strokeStyle = state.color;
        page.drawingContext.lineWidth = state.strokeWidth;
        page.drawingContext.lineCap = 'round';
        page.drawingContext.lineJoin = 'round';
        page.drawingContext.beginPath();
        page.drawingContext.moveTo(x, y);
      } else if (state.tool === 'redact') {
        event.target.setPointerCapture(event.pointerId);
        state.dragInfo = {
          type: 'redaction',
          startX: x,
          startY: y,
        };
      }
    }

    function handlePointerMove(event, page) {
      if (!state.dragInfo) return;
      const rect = page.overlay.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      if (state.dragInfo.type === 'drawing') {
        state.dragInfo.points.push({ x, y });
        page.drawingContext.lineTo(x, y);
        page.drawingContext.stroke();
      } else if (state.dragInfo.type === 'redaction') {
        const { startX, startY } = state.dragInfo;
        const width = x - startX;
        const height = y - startY;
        drawPreviewRectangle(page, startX, startY, width, height);
      }
    }

    function drawPreviewRectangle(page, x, y, width, height) {
      if (!page.previewLayer) {
        const previewCanvas = document.createElement('canvas');
        const displayWidth = page.displayWidth || page.baseCanvas.width;
        const displayHeight = page.displayHeight || page.baseCanvas.height;
        const ratio = page.pixelRatio || 1;
        previewCanvas.width = Math.round(displayWidth * ratio);
        previewCanvas.height = Math.round(displayHeight * ratio);
        previewCanvas.style.position = 'absolute';
        previewCanvas.style.inset = '0';
        previewCanvas.style.pointerEvents = 'none';
        previewCanvas.style.width = `${displayWidth}px`;
        previewCanvas.style.height = `${displayHeight}px`;
        page.overlay.appendChild(previewCanvas);
        page.previewLayer = previewCanvas;
        page.previewContext = previewCanvas.getContext('2d');
        if (ratio !== 1) {
          page.previewContext.scale(ratio, ratio);
        }
      }
      const ctx = page.previewContext || page.previewLayer.getContext('2d');
      const displayWidth = page.displayWidth || page.baseCanvas.width;
      const displayHeight = page.displayHeight || page.baseCanvas.height;
      ctx.clearRect(0, 0, displayWidth, displayHeight);
      const rectX = width < 0 ? x + width : x;
      const rectY = height < 0 ? y + height : y;
      const rectWidth = Math.abs(width);
      const rectHeight = Math.abs(height);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
      ctx.strokeStyle = '#111827';
      ctx.lineWidth = 1;
      ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
    }

    function finalizeRedaction(page, startX, startY, endX, endY) {
      const rectX = Math.min(startX, endX);
      const rectY = Math.min(startY, endY);
      const width = Math.abs(endX - startX);
      const height = Math.abs(endY - startY);
      page.drawingContext.fillStyle = '#ffffff';
      page.drawingContext.fillRect(rectX, rectY, width, height);
      page.annotations.redactions.push({ x: rectX, y: rectY, width, height });
      if (page.previewLayer) {
        page.previewLayer.remove();
        delete page.previewLayer;
        delete page.previewContext;
      }
    }

    function handlePointerUp(event, page) {
      if (!state.dragInfo) return;
      const rect = page.overlay.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      if (state.dragInfo.type === 'drawing') {
        page.annotations.drawings.push({
          points: state.dragInfo.points,
          color: state.color,
          width: state.strokeWidth,
        });
      } else if (state.dragInfo.type === 'redaction') {
        finalizeRedaction(page, state.dragInfo.startX, state.dragInfo.startY, x, y);
      }
      if (event.target && typeof event.target.hasPointerCapture === 'function' && event.target.hasPointerCapture(event.pointerId)) {
        event.target.releasePointerCapture(event.pointerId);
      }
      state.dragInfo = null;
      refreshThumbnails();
    }

    function handleOverlayClick(event, page, target) {
      if (target && target !== page.overlay && !target.classList.contains('drawing-layer')) {
        return;
      }
      const rect = page.overlay.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      if (state.tool === 'text') {
        createTextBox(page, x, y);
      } else if (state.tool === 'note') {
        createNoteCard(page, x, y);
      } else if (state.tool === 'comment') {
        createComment(page, x, y);
      } else if (state.tool === 'image') {
        state.pendingImagePosition = { x, y };
        elements.imageInput.value = '';
        elements.imageInput.click();
      }
    }

    function createTextBox(page, x, y) {
      const id = createId('text');
      const div = document.createElement('div');
      div.className = 'text-box';
      div.contentEditable = 'true';
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.width = '160px';
      div.style.height = '60px';
      div.style.color = state.color;
      div.style.fontSize = `${state.fontSize}px`;
      div.dataset.id = id;
      div.textContent = 'Edit text';

      const handle = document.createElement('div');
      handle.className = 'resize-handle';
      handle.contentEditable = 'false';
      div.appendChild(handle);

      page.annotationLayer.appendChild(div);
      div.focus();

      const annotation = {
        id,
        x,
        y,
        width: 160,
        height: 60,
        content: div.textContent,
        color: state.color,
        fontSize: state.fontSize,
      };
      page.annotations.texts.push(annotation);

      enableDrag(div, annotation, page);
      enableResize(div, handle, annotation, page);

      div.addEventListener('input', () => {
        annotation.content = div.textContent;
        refreshThumbnails();
      });

      div.addEventListener('blur', () => {
        annotation.content = div.textContent;
        refreshThumbnails();
      });

      refreshThumbnails();
    }

    function createNoteCard(page, x, y) {
      const id = createId('note');
      const note = document.createElement('div');
      note.className = 'note-card';
      note.contentEditable = 'true';
      note.style.left = `${x}px`;
      note.style.top = `${y}px`;
      note.style.width = '180px';
      note.style.height = '120px';
      note.dataset.id = id;
      note.textContent = 'Add note...';

      const handle = document.createElement('div');
      handle.className = 'resize-handle';
      handle.contentEditable = 'false';
      note.appendChild(handle);

      page.annotationLayer.appendChild(note);
      note.focus();

      const annotation = { id, x, y, width: 180, height: 120, content: note.textContent };
      page.annotations.notes.push(annotation);

      enableDrag(note, annotation, page);
      enableResize(note, handle, annotation, page);

      note.addEventListener('input', () => {
        annotation.content = note.textContent;
        refreshThumbnails();
      });

      refreshThumbnails();
    }

    function enableDrag(element, annotation, page) {
      let startX, startY, initialX, initialY;
      const onPointerDown = (event) => {
        if (state.tool !== 'select') return;
        startX = event.clientX;
        startY = event.clientY;
        initialX = parseFloat(element.style.left);
        initialY = parseFloat(element.style.top);
        element.setPointerCapture(event.pointerId);
        element.classList.add('dragging');
      };

      const onPointerMove = (event) => {
        if (!element.classList.contains('dragging')) return;
        const dx = event.clientX - startX;
        const dy = event.clientY - startY;
        const newX = initialX + dx;
        const newY = initialY + dy;
        element.style.left = `${newX}px`;
        element.style.top = `${newY}px`;
        annotation.x = newX;
        annotation.y = newY;
      };

      const onPointerUp = (event) => {
        if (!element.classList.contains('dragging')) return;
        element.releasePointerCapture(event.pointerId);
        element.classList.remove('dragging');
        refreshThumbnails();
      };

      element.addEventListener('pointerdown', onPointerDown);
      element.addEventListener('pointermove', onPointerMove);
      element.addEventListener('pointerup', onPointerUp);
    }

    function enableResize(element, handle, annotation, page) {
      if (!handle) return;
      let startX, startY, startWidth, startHeight;
      const onPointerDown = (event) => {
        if (state.tool !== 'select') return;
        event.stopPropagation();
        startX = event.clientX;
        startY = event.clientY;
        startWidth = element.offsetWidth;
        startHeight = element.offsetHeight;
        handle.setPointerCapture(event.pointerId);
        handle.dataset.resizing = 'true';
      };

      const onPointerMove = (event) => {
        if (handle.dataset.resizing !== 'true') return;
        const dx = event.clientX - startX;
        const dy = event.clientY - startY;
        const newWidth = Math.max(80, startWidth + dx);
        const newHeight = Math.max(40, startHeight + dy);
        element.style.width = `${newWidth}px`;
        element.style.height = `${newHeight}px`;
        annotation.width = newWidth;
        annotation.height = newHeight;
        if (element.classList.contains('image-box')) {
          const img = element.querySelector('img');
          if (img) {
            img.style.width = `${newWidth}px`;
            img.style.height = `${newHeight}px`;
          }
        }
      };

      const onPointerUp = (event) => {
        if (handle.dataset.resizing !== 'true') return;
        handle.releasePointerCapture(event.pointerId);
        delete handle.dataset.resizing;
        refreshThumbnails();
      };

      handle.addEventListener('pointerdown', onPointerDown);
      handle.addEventListener('pointermove', onPointerMove);
      handle.addEventListener('pointerup', onPointerUp);
    }

    function createComment(page, x, y) {
      const text = prompt('Comment');
      if (!text) return;
      if (state.commentsCollapsed) {
        setCommentsCollapsed(false);
      }
      const id = createId('comment');
      const marker = document.createElement('div');
      marker.className = 'comment-marker';
      const label = state.commentCounter++;
      marker.textContent = label;
      marker.style.left = `${x}px`;
      marker.style.top = `${y}px`;
      marker.dataset.id = id;
      page.annotationLayer.appendChild(marker);

      const annotation = { id, x, y, text, label };
      page.annotations.comments.push(annotation);

      marker.addEventListener('click', () => {
        focusComment(id);
      });

      refreshThumbnails();
      updateCommentList();
    }

    function focusComment(id) {
      if (state.commentsCollapsed) {
        setCommentsCollapsed(false);
      }
      const entry = elements.commentList.querySelector(`[data-id="${id}"]`);
      if (entry) {
        elements.commentList.querySelectorAll('li.highlight').forEach(li => li.classList.remove('highlight'));
        entry.scrollIntoView({ behavior: 'smooth', block: 'center' });
        entry.classList.add('highlight');
        setTimeout(() => entry.classList.remove('highlight'), 1600);
      }
    }

    function updateCommentList() {
      elements.commentList.innerHTML = '';
      state.pages.forEach((page, pageIndex) => {
        page.annotations.comments.forEach(comment => {
          const item = document.createElement('li');
          item.dataset.id = comment.id;
          const label = document.createElement('strong');
          label.textContent = `Page ${pageIndex + 1} Â· #${comment.label}`;
          const body = document.createElement('p');
          body.textContent = comment.text;
          item.appendChild(label);
          item.appendChild(body);
          item.addEventListener('click', () => {
            setActivePage(pageIndex);
            elements.commentList.querySelectorAll('li.highlight').forEach(li => li.classList.remove('highlight'));
            item.classList.add('highlight');
            const marker = page.annotationLayer.querySelector(`.comment-marker[data-id="${comment.id}"]`);
            if (marker) {
              marker.classList.add('active');
              setTimeout(() => marker.classList.remove('active'), 1200);
            }
          });
          elements.commentList.appendChild(item);
        });
      });
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const paragraphs = String(text || '').split(/\n/);
      paragraphs.forEach((paragraph, index) => {
        const words = paragraph.split(/\s+/);
        let line = '';
        words.forEach((word) => {
          if (!word) return;
          const testLine = line + word + ' ';
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && line !== '') {
            ctx.fillText(line, x, y);
            line = word + ' ';
            y += lineHeight;
          } else {
            line = testLine;
          }
        });
        ctx.fillText(line, x, y);
        if (index !== paragraphs.length - 1) {
          y += lineHeight;
        }
      });
    }

    function wrapTextThumbnail(ctx, text, x, y, maxWidth, lineHeight) {
      const paragraphs = String(text || '').split(/\n/);
      paragraphs.forEach((paragraph, index) => {
        const words = paragraph.split(/\s+/);
        let line = '';
        words.forEach((word) => {
          if (!word) return;
          const testLine = line + word + ' ';
          if (ctx.measureText(testLine).width > maxWidth && line !== '') {
            ctx.fillText(line, x, y);
            line = word + ' ';
            y += lineHeight;
          } else {
            line = testLine;
          }
        });
        ctx.fillText(line, x, y);
        if (index !== paragraphs.length - 1) {
          y += lineHeight;
        }
      });
    }

    function refreshThumbnails() {
      Array.from(elements.thumbnails.children).forEach((thumb, index) => {
        const canvas = thumb.querySelector('canvas');
        if (!canvas) return;
        updateThumbnailCanvas(canvas, state.pages[index]);
      });
    }

    function isPdfFile(file) {
      if (!file) return false;
      if (file.type === 'application/pdf') return true;
      const name = file.name || '';
      return name.toLowerCase().endsWith('.pdf');
    }

    async function openPdfFile(file) {
      if (!file) return;
      if (!isPdfFile(file)) {
        showToast('Please choose a PDF file');
        return;
      }
      try {
        const arrayBuffer = await file.arrayBuffer();
        await loadPdfFromArrayBuffer(arrayBuffer, file.name || 'PDF document');
      } catch (error) {
        console.error(error);
        showToast('Unable to read the selected file');
      }
    }

    elements.colorPicker.addEventListener('change', (event) => {
      state.color = event.target.value;
      const active = document.activeElement;
      if (active && active.classList.contains('text-box')) {
        active.style.color = state.color;
        const page = state.pages[state.activePageIndex];
        if (page) {
          const annotation = page.annotations.texts.find(item => item.id === active.dataset.id);
          if (annotation) {
            annotation.color = state.color;
            refreshThumbnails();
          }
        }
      }
    });

    elements.strokeWidth.addEventListener('change', (event) => {
      state.strokeWidth = parseInt(event.target.value, 10) || 3;
    });

    elements.fontSize.addEventListener('change', (event) => {
      state.fontSize = parseInt(event.target.value, 10) || 18;
      const active = document.activeElement;
      if (active && active.classList.contains('text-box')) {
        active.style.fontSize = `${state.fontSize}px`;
        const page = state.pages[state.activePageIndex];
        if (page) {
          const annotation = page.annotations.texts.find(item => item.id === active.dataset.id);
          if (annotation) {
            annotation.fontSize = state.fontSize;
            refreshThumbnails();
          }
        }
      }
    });

    elements.toolButtons.forEach((button) => {
      button.addEventListener('click', () => setTool(button.dataset.tool));
    });

    elements.toggleCommentsBtn?.addEventListener('click', () => {
      setCommentsCollapsed(!state.commentsCollapsed);
    });

    elements.openBtn.addEventListener('click', () => {
      elements.fileInput.value = '';
      elements.fileInput.click();
    });

    elements.fileInput.addEventListener('change', async (event) => {
      const files = event.target.files;
      const file = files && files[0];
      if (!file) return;
      await openPdfFile(file);
      event.target.value = '';
    });

    elements.imageInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file || !state.pendingImagePosition) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        insertImage(state.pendingImagePosition.x, state.pendingImagePosition.y, e.target.result);
        state.pendingImagePosition = null;
      };
      reader.readAsDataURL(file);
    });

    function insertImage(x, y, dataUrl) {
      const page = state.pages[state.activePageIndex];
      if (!page) {
        showToast('Open a PDF before adding images');
        return;
      }
      const id = createId('image');
      const imgWrapper = document.createElement('div');
      imgWrapper.className = 'image-box';
      imgWrapper.style.left = `${x}px`;
      imgWrapper.style.top = `${y}px`;
      imgWrapper.dataset.id = id;
      imgWrapper.style.width = '240px';
      imgWrapper.style.height = '160px';

      const img = document.createElement('img');
      img.src = dataUrl;
      img.style.display = 'block';
      img.style.width = '240px';
      img.style.height = 'auto';
      imgWrapper.appendChild(img);

      const handle = document.createElement('div');
      handle.className = 'resize-handle';
      imgWrapper.appendChild(handle);

      page.annotationLayer.appendChild(imgWrapper);

      const annotation = {
        id,
        x,
        y,
        width: 240,
        height: 160,
        dataUrl,
      };
      page.annotations.images.push(annotation);

      img.onload = () => {
        const ratio = img.naturalWidth / img.naturalHeight;
        annotation.height = annotation.width / ratio;
        imgWrapper.style.width = `${annotation.width}px`;
        imgWrapper.style.height = `${annotation.height}px`;
        img.style.width = `${annotation.width}px`;
        img.style.height = `${annotation.height}px`;
        enableDrag(imgWrapper, annotation, page);
        enableResize(imgWrapper, handle, annotation, page);
        refreshThumbnails();
      };
    }

    elements.addPageBtn.addEventListener('click', () => {
      const basePage = state.pages[state.activePageIndex];
      const width = basePage ? basePage.displayWidth : 612;
      const height = basePage ? basePage.displayHeight : 792;
      const ratio = basePage ? basePage.pixelRatio : getCanvasPixelRatio();
      const { wrapper, baseCanvas, overlay, drawingLayer, drawingContext, annotationLayer, pixelRatio } = createPageContainer(width, height, ratio);
      const ctx = baseCanvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);
      const annotations = {
        drawings: [],
        texts: [],
        notes: [],
        images: [],
        redactions: [],
        comments: [],
      };
      const page = {
        container: wrapper,
        baseCanvas,
        overlay,
        drawingLayer,
        drawingContext,
        annotationLayer,
        annotations,
        pixelRatio,
        displayWidth: width,
        displayHeight: height,
      };
      addPage(page, state.activePageIndex + 1);
    });

    elements.duplicatePageBtn.addEventListener('click', () => {
      const sourcePage = state.pages[state.activePageIndex];
      const { wrapper, baseCanvas, overlay, drawingLayer, drawingContext, annotationLayer, pixelRatio } = createPageContainer(sourcePage.displayWidth, sourcePage.displayHeight, sourcePage.pixelRatio);
      const ctx = baseCanvas.getContext('2d');
      ctx.drawImage(sourcePage.baseCanvas, 0, 0);
      drawingContext.save();
      drawingContext.setTransform(1, 0, 0, 1, 0, 0);
      drawingContext.drawImage(sourcePage.drawingLayer, 0, 0);
      drawingContext.restore();
      const annotations = {
        drawings: JSON.parse(JSON.stringify(sourcePage.annotations.drawings)),
        texts: JSON.parse(JSON.stringify(sourcePage.annotations.texts)),
        notes: JSON.parse(JSON.stringify(sourcePage.annotations.notes)),
        images: JSON.parse(JSON.stringify(sourcePage.annotations.images)),
        redactions: JSON.parse(JSON.stringify(sourcePage.annotations.redactions)),
        comments: JSON.parse(JSON.stringify(sourcePage.annotations.comments)),
      };
      annotations.comments = annotations.comments.map(original => {
        const cloned = { ...original };
        cloned.id = createId('comment');
        cloned.label = state.commentCounter++;
        return cloned;
      });
      const page = {
        container: wrapper,
        baseCanvas,
        overlay,
        drawingLayer,
        drawingContext,
        annotationLayer,
        annotations,
        pixelRatio,
        displayWidth: sourcePage.displayWidth,
        displayHeight: sourcePage.displayHeight,
      };
      restoreAnnotations(page);
      addPage(page, state.activePageIndex + 1);
    });

    function restoreAnnotations(page) {
      page.annotations.texts.forEach(annotation => {
        const div = document.createElement('div');
        div.className = 'text-box';
        div.contentEditable = 'true';
        div.style.left = `${annotation.x}px`;
        div.style.top = `${annotation.y}px`;
        div.style.width = `${annotation.width}px`;
        div.style.height = `${annotation.height}px`;
        div.style.fontSize = `${annotation.fontSize}px`;
        div.style.color = annotation.color;
        div.dataset.id = annotation.id;
        div.textContent = annotation.content;
        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        handle.contentEditable = 'false';
        div.appendChild(handle);
        page.annotationLayer.appendChild(div);
        enableDrag(div, annotation, page);
        enableResize(div, handle, annotation, page);
        div.addEventListener('input', () => {
          annotation.content = div.textContent;
          refreshThumbnails();
        });
        div.addEventListener('blur', () => {
          annotation.content = div.textContent;
          refreshThumbnails();
        });
      });

      page.annotations.notes.forEach(annotation => {
        const note = document.createElement('div');
        note.className = 'note-card';
        note.contentEditable = 'true';
        note.style.left = `${annotation.x}px`;
        note.style.top = `${annotation.y}px`;
        note.style.width = `${annotation.width}px`;
        note.style.height = `${annotation.height}px`;
        note.dataset.id = annotation.id;
        note.textContent = annotation.content;
        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        handle.contentEditable = 'false';
        note.appendChild(handle);
        page.annotationLayer.appendChild(note);
        enableDrag(note, annotation, page);
        enableResize(note, handle, annotation, page);
        note.addEventListener('input', () => {
          annotation.content = note.textContent;
          refreshThumbnails();
        });
      });

      page.annotations.images.forEach(annotation => {
        const imgWrapper = document.createElement('div');
        imgWrapper.className = 'image-box';
        imgWrapper.style.left = `${annotation.x}px`;
        imgWrapper.style.top = `${annotation.y}px`;
        imgWrapper.dataset.id = annotation.id;
        const img = document.createElement('img');
        img.src = annotation.dataUrl;
        img.style.width = `${annotation.width}px`;
        img.style.height = `${annotation.height}px`;
        imgWrapper.appendChild(img);
        imgWrapper.style.width = `${annotation.width}px`;
        imgWrapper.style.height = `${annotation.height}px`;
        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        handle.contentEditable = 'false';
        imgWrapper.appendChild(handle);
        page.annotationLayer.appendChild(imgWrapper);
        enableDrag(imgWrapper, annotation, page);
        enableResize(imgWrapper, handle, annotation, page);
      });

      page.annotations.comments.forEach(annotation => {
        const marker = document.createElement('div');
        marker.className = 'comment-marker';
        marker.dataset.id = annotation.id;
        marker.textContent = annotation.label;
        marker.style.left = `${annotation.x}px`;
        marker.style.top = `${annotation.y}px`;
        page.annotationLayer.appendChild(marker);
        marker.addEventListener('click', () => focusComment(annotation.id));
        if (annotation.label >= state.commentCounter) {
          state.commentCounter = annotation.label + 1;
        }
      });
    }

    elements.downloadBtn.addEventListener('click', async () => {
      try {
        const pdfDoc = await PDFLib.PDFDocument.create();
        for (const page of state.pages) {
          const composed = await composePageCanvas(page);
          const pngBytes = await fetch(composed.toDataURL('image/png')).then(res => res.arrayBuffer());
          const pngImage = await pdfDoc.embedPng(pngBytes);
          const pdfWidth = page.displayWidth || page.baseCanvas.width;
          const pdfHeight = page.displayHeight || page.baseCanvas.height;
          const pdfPage = pdfDoc.addPage([pdfWidth, pdfHeight]);
          pdfPage.drawImage(pngImage, {
            x: 0,
            y: 0,
            width: pdfWidth,
            height: pdfHeight,
          });
        }
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'openpdf-export.pdf';
        link.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error(error);
        showToast('Failed to export PDF');
      }
    });

    async function composePageCanvas(page) {
      const canvas = document.createElement('canvas');
      const displayWidth = page.displayWidth || page.baseCanvas.width;
      const displayHeight = page.displayHeight || page.baseCanvas.height;
      const ratio = page.pixelRatio || 1;
      canvas.width = Math.round(displayWidth * ratio);
      canvas.height = Math.round(displayHeight * ratio);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(page.baseCanvas, 0, 0);
      ctx.drawImage(page.drawingLayer, 0, 0);

      ctx.save();
      if (ratio !== 1) {
        ctx.scale(ratio, ratio);
      }

      page.annotations.redactions.forEach(redaction => {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(redaction.x, redaction.y, redaction.width, redaction.height);
      });

      for (const text of page.annotations.texts) {
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillRect(text.x, text.y, text.width, text.height);
        ctx.fillStyle = text.color;
        ctx.font = `${text.fontSize}px Inter`;
        ctx.textBaseline = 'top';
        wrapText(ctx, text.content, text.x + 4, text.y + 4, text.width - 8, text.fontSize * 1.2);
        ctx.restore();
      }

      for (const note of page.annotations.notes) {
        ctx.save();
        ctx.fillStyle = '#fff8c6';
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = 1;
        ctx.shadowColor = 'rgba(0,0,0,0.15)';
        ctx.shadowBlur = 6;
        ctx.fillRect(note.x, note.y, note.width, note.height);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#3f3210';
        ctx.font = '14px Inter';
        ctx.textBaseline = 'top';
        wrapText(ctx, note.content, note.x + 8, note.y + 16, note.width - 16, 18);
        ctx.restore();
      }

      for (const image of page.annotations.images) {
        await drawImageOnCanvas(ctx, image);
      }

      for (const comment of page.annotations.comments) {
        ctx.save();
        ctx.fillStyle = '#3f51b5';
        ctx.beginPath();
        ctx.arc(comment.x, comment.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(comment.label), comment.x, comment.y);
        ctx.restore();
      }

      ctx.restore();

      return canvas;
    }

    function drawImageOnCanvas(ctx, image) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, image.x, image.y, image.width, image.height);
          resolve();
        };
        img.src = image.dataUrl;
      });
    }

    document.addEventListener('dragover', (event) => {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'copy';
    });

    document.addEventListener('drop', async (event) => {
      event.preventDefault();
      const transfer = event.dataTransfer;
      if (!transfer || !transfer.files || transfer.files.length === 0) {
        return;
      }
      const file = transfer.files[0];
      await openPdfFile(file);
    });

    showToast('Welcome to OpenPDF Prototype');
  </script>
</body>
</html>
